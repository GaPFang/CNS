import numpy as np
import sys

# RSA

def egcd(a, b):
    if a == 0:
        return (b, 0, 1)
    else:
        g, x, y = egcd(b % a, a)
        return (g, y - (b // a) * x, x)
    
def modinv(a, m): # modular inverse
    g, x, y = egcd(a, m)
    if g != 1:
        raise Exception('modular inverse does not exist')
    else:
        return x % m
    
def chinese_remainder_theorem(n1, n2, c1, c2):
    m1 = n2 * modinv(n2, n1)
    m2 = n1 * modinv(n1, n2)
    return (c1 * m1 + c2 * m2) % (n1 * n2)

def dec_to_hex_to_ascii(dec):
    hex_str = hex(dec)[2:]
    print(hex_str)
    if len(hex_str) % 2 != 0:
        hex_str = '0' + hex_str
    return bytes.fromhex(hex_str).decode('utf-8')

def main():
    n = 842300711749050747221769727792528259004539753404486821468017562424643903549422874964649390736408385551189284350566296626888652072661740507522495731585775240238814860050008640230860870397683741436238049961570243746855599069477245159550405853853149158043789089630940332136416243722285435050838245554350127439445813927674306253873212269754150086263819084842308232451765669103808630724364666625454821621900918385756918654914866925579089787692435814411582506078666587156948751339007195405365994551915839045142087920085423289918260103741578797780288168878414059649437686553413116373057272932526486417067877805178297701659196888991559690112795552285313083065086896903507510359096495614302519359695842251491451094104323739420438364079954852474669373011550870458199047248408018628469681212305049245595273027245943441407871641754313701414594277289924047551195690721069905363823715923981849916855137039972693895128746763394361291445065588105550421491345685907786871217492399074066413241078828218729830999037746588183127975404604957746029149211998751350006610658794514945167452494521919918951490660714814709412168577894444148603299904469281515998979099232947316892159160625767760218805717339214832540175760333244818948896583821912178573535261283
    e1 = 65537
    e2 = 100003
    c1 = 681786767371085193003520750453670054304307979631935719813554212303387922933083172524264050650780766691825954130919657981079325020888250680774369738912832051899488805689121960005427782315684678469698439263421232002641693249032278773256563382395587825933859668018504294663928065401860018274539473682956185709289179575898668637246951670945189280631882095326606514473452493052549394358124759327470118638790354815101195738533292423176416281225824293287386657185094958612991693226049627800929288846721360792179535782139417117050151570438674567524869081643355085001462883351224186875669744194577074678094552141369479027321726529313375709857772425775660319430913603594634264834022328173813615683305863838944598118978534209291696089143064246865379833624417825478635194236826983349704227377373619318631048532912780466718440120492905399593007717849851322040361022565881393235746387524426222067983751300589999199766121073542160475591855613168351805202097216018451718161541617380096812389859635821160498766108177957384545970180372074969952587486846932385483087540052080305529398195544334545039785771928525518315290811800103050613186553662963814825215796941774806798946817650424358595056015935296168471407828845884427997683759539320926606118988645
    c2 = 647370162676353206612167672060380324334979315530097026686554246959331924467858452352672258877341677338077559885842890165216321104129644509282985482792224028440207379273012210456676886121635774409509420409146960133387894951150706977187621765278070726931567034190796663899759784239029993171724363870545402250432333981550550236897329614736722271464682740444656473245186129349729160580403265362918031739318240339622247805314699471318861439479347408902716476437900761419379837111227245055644885457211022500664899845124752318297370200963923703687372289546614651040345041760459968171666700946411518397692236372766172009992593699864823039957874440967919478072159359751466021763764553498088079361734141738107940264399185028337103342483661992289807567805653540684495243956748953087929555803159477268250357847756182197457471685584152011774424879781741063905945057430342120003831235140109312467228491244518008237281361330001366468427930823634789462953382827236242692343360836563863239543582133410953759543391749038607784210671905591381077700749643356534784007697230363317270558640263511437616721651785476105749478575606709386330009701649633145008137916244655667698037251003685565281105702385404293473108026092602461080619241404375141169005113013
    
    sys.setrecursionlimit(3000)

    if e1 < e2:
        e1, e2 = e2, e1
        c1, c2 = c2, c1
    while e2 > 1:
        print("e1, e2: ", e1, e2)
        quotient = e1 // e2
        # print("quotient: ", quotient)
        e1 -= e2 * quotient
        c1 = (c1 * (modinv(c2, n) ** quotient)) % n
        e1, e2 = e2, e1
        c1, c2 = c2, c1
    print("final: ", e1, e2)
    print(c1)
    print(c2)
    print(dec_to_hex_to_ascii(c2))

if __name__ == '__main__':
    main()